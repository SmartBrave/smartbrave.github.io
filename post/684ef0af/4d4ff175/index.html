<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=0.5">

        <link href="/css/main.css" rel="stylesheet" type="text/css">
        <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">
        <link rel="shortcut icon" href="/image/Yc.jpg">
        <link href="/css/prism.css" rel="stylesheet" />
        <title>面试题24：二叉搜索时的后序遍历序列</title>
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-78070816-3"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            
            gtag('config', 'UA-78070816-3');
        </script>
    </head>
    <body>
        <!-- suppport block of mathjax -->
        <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
        <!-- support mathjax inline -->
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({
                tex2jax: {inlineMath: [['$','$']]},
                messageStyle: "none"
            });
        </script>
        <script>
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent)){
                document.body.classList.add('mobile');
            }
        </script>
        <script src="/js/prism.js"></script>
        <div class="inner">
            <h2>面试题24：二叉搜索时的后序遍历序列</h2>

<p><strong>题目：输入一个整数数组，判断该数组是不是某二叉搜索时的后序遍历的结果。如果是则返回true，否则返回false。假设输入的数组的任一两个数字都不相同。</strong></p>

<hr />

<h3>分析</h3>

<p>我们先假设该数组是某颗二叉搜索树的后序遍历序列，则它有如下性质：</p>

<ul>
<li>数组最后一个元素是该二叉树的根节点；</li>
<li>若数组为arr，长度为n，则arr[0..k-1]<arr[n-1],arr[k..n-2]>arr[n-1]，(0&lt;=k&lt;=n-1)；</li>
<li>对arr[0..k-1]和arr[k..n-2]同样适用于这些规律；
不难看出，这是一个递归的思想。数组中前面一部分数字会小于最后一个数字（对应于根节点的左子树），后面一部分数字会大于最后一个数字（对应于根节点的右子树），因此可以递归地对他们进行判断。</li>
</ul>

<p>代码如下：</p>

<pre><code class="language-C">class ArgIsError{};

template
bool compair(const T&amp;amp; t1,const T&amp;amp; t2)
{
    return t1&gt;t2;
}

template
bool IsMax(const vector&amp;amp; v,int start,int end,const T&amp;amp; t)throw (ArgIsError)
{
    if(v.size()end)
        throw ArgIsError();
    int i;
    for(i=start;i&lt;end;++i)
    {
        if(compair(v[i],t))
            return false;
    }
    return true;
}
template
bool IsMin(const vector&amp;amp; v,int start,int end,const T&amp;amp; t)throw (ArgIsError)
{
    if(v.size()end)
        throw ArgIsError();
    int i;
    for(i=start;i&lt;end;++i)
    {
        if(!compair(v[i],t))
            return false;
    }
    return true;
}

template
bool VerifySquenceOfBST(const vector&amp;amp; sequence)
{
    if(sequence.size()=0;--i)
    {
        if(sequence[i]&lt;sequence[length-1])
        {
            left=0;
            right=i+1;
            break;
        }
    }
    try
    {
        if(!IsMax(sequence,left,right,sequence[length-1]) || !IsMin(sequence,right,length-1,sequence[length-1]))
        {
            return false;
        }
    }
    catch(ArgIsError&amp;amp;)
    {
        ;
    }
    vector lseq(sequence.begin()+left,sequence.begin()+right),rseq(sequence.begin()+right,sequence.begin()+length-1);
    if(VerifySquenceOfBST(lseq) &amp;amp;&amp;amp; VerifySquenceOfBST(rseq))
    {
        return true;
    }
    else
    {
        return false;
    }
}
</code></pre>

<p><strong>以上</strong></p>

<p>如果你有任何想法或是可以改进的地方，欢迎和我交流！</p>

<p>完整代码及测试用例在github上：<a href="https://github.com/SmartBrave/Sword-to-Offer/blob/master/24_SquenceOfBST/main.cpp">点我前往</a>
<div><a href="http://www.wiz.cn/i/96171253 &quot;来自为知笔记(Wiz">来自为知笔记(Wiz)</a>&quot;)</div></p>

        </div>
    </body>
</html>

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/haoel/anti-baidu@0.6.2/js/anti-baidu-latest.min.js" charset="UTF-8"></script>
