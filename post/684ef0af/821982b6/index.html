<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=0.5">

    <link href="/css/main.css" rel="stylesheet" type="text/css">
    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">
    <link rel="shortcut icon" href="/image/Yc.jpg">
    <link href="/css/prism.css" rel="stylesheet" />
    <title>面试题39：二叉树的深度</title>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-78070816-3"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }
        gtag('js', new Date());

        gtag('config', 'UA-78070816-3');
    </script>
</head>

<body>
    <!-- suppport block of mathjax -->
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
    <!-- support mathjax inline -->
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
                tex2jax: {inlineMath: [['$','$']]},
                messageStyle: "none"
            });
        </script>
    <script>
        if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent)) {
            document.body.classList.add('mobile');
        }
    </script>
    <script src="/js/prism.js"></script>
    <div class="inner">
        <h2>面试题39：二叉树的深度</h2>

<p><strong>题目一：输入一颗二叉树的根节点，求该树的深度。从根节点到叶节点一次经过的节点形成树的一条路径，最长路径的长度为树的深度。</strong></p>

<p>二叉树节点定义如下：</p>

<p>```struct BinaryTreeNode
{
    int value;
    BinaryTreeNode* left;
    BinaryTreeNode* right;
    BinaryTreeNode(int data=int())
       :value(data),left(NULL),right(NULL)
    {}
}</p>

<pre><code>
* * *

### 分析

此题可利用递归很方便的完成，步骤如下：

*   判断参数root是否为空？为空就返回0；
*   否则计算root的左右子树的高度；
*   比较左右子树高度，取较大者，返回较大的值加1（root自身占一层）。

代码如下：

```int Depth(BinaryTreeNode* root)
{
    if(root==NULL)
        return 0;
    int LeftDepth=Depth(root-&gt;left);
    int RightDepth=Depth(root-&gt;right);
    return LeftDepth&gt;RightDepth?LeftDepth+1:RightDepth+1;
}
</code></pre>

<p><strong>题目二：输入一颗二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意两个节点的左右子树的深度相差不超过1，那么它就是一颗平衡二叉树。</strong></p>

<hr />

<h3>分析</h3>

<p>最容易想到的就是遍历二叉树，每遍历到一个节点时，去求它的左右子树的深度并比较即可。然而这种方法需要将很多节点遍历多次。如下图：</p>

<p><img src="/images/BinTree.png" width="100%" height="100%"></p>

<p>求1的深度时，需要遍历剩下的所有节点。然后求2的深度时，需要遍历4和7两个节点。求3的深度时，又需要遍历5,6,8三个节点。这样导致时间复杂度较高。</p>

<p>有没有办法减少遍历节点的次数呢？答案是有的。那就是将每次遍历过的节点保存起来。我们可以将从根节点到叶节点所经过的所有节点看成一条路径。每次向下进入子树时，将当前节点保存进路径里面。从子树退回到父节点时，再将它从路径中删除。如此，我们便可以只遍历一次。求遍历过程中路径的最大值就可以，即最长路径。</p>

<p>代码如下：</p>

<p>```bool <em>IsBalanced(BinaryTreeNode* root,int&amp; depth)
{
    if(root==NULL)
    {
        depth=0;
        return true;
    }
    int left,right;
    if(</em>IsBalaced(root-&gt;left,left) &amp;&amp; _IsBalanced(root-&gt;right,right)
    {
        int diff=right-left;
        if(diff&gt;=-1 &amp;&amp; diff &lt;=1)
        {
            depth=left&gt;right?left+1:right+1;
            return true;
        }
    }
    return false;
}</p>

<p>bool IsBalanced(BinaryTreeNode* root)
{
    int depth=0;
    return _IsBalanced(root,depth);
}
```</p>

<p><strong>以上</strong></p>

<p>如果你有任何想法或是可以改进的地方，欢迎和我交流！</p>

<p>完整代码及测试用例在github上：<a href="https://github.com/SmartBrave/Sword-to-Offer/blob/master/39_1_TreeDepth/main.cpp">点我前往(题目一)</a>&nbsp;&nbsp;<a href="https://github.com/SmartBrave/Sword-to-Offer/blob/master/39_2_BalancedBinaryTree/main.cpp">点我前往(题目二)</a></p>

<div>[来自为知笔记(Wiz)](http://www.wiz.cn/i/96171253 "来自为知笔记(Wiz)")</div>
来自为知笔记(Wiz)")</div>

    </div>
</body>

<footer>
    <div class="footer">
        Copyright © sbrave 2021
        <br>
        陕ICP备16005721号-1
    </div>
</footer>

</html>

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/haoel/anti-baidu@0.6.2/js/anti-baidu-latest.min.js" charset="UTF-8"></script>
