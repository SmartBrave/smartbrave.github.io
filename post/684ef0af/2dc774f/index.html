<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=0.5">

    <link href="/css/main.css" rel="stylesheet" type="text/css">
    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">
    <link rel="shortcut icon" href="/image/Yc.jpg">
    <link href="/css/prism.css" rel="stylesheet" />
    <title>面试题23：从上往下打印二叉树</title>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-78070816-3"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }
        gtag('js', new Date());

        gtag('config', 'UA-78070816-3');
    </script>
</head>

<body>
    <!-- suppport block of mathjax -->
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
    <!-- support mathjax inline -->
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
                tex2jax: {inlineMath: [['$','$']]},
                messageStyle: "none"
            });
        </script>
    <script>
        if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent)) {
            document.body.classList.add('mobile');
        }
    </script>
    <script src="/js/prism.js"></script>
    <div class="inner">
        <h2>面试题23：从上往下打印二叉树</h2>

<p><strong>题目：从上往下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。例如输入下图所示的二叉树，则依次打印出8,6,10,5,7,9,11.</strong></p>

<p><img src="/images/OrderBinTree.png" width="100%" height="100%"></p>

<p>二叉树的节点定义如下：</p>

<pre><code>struct BinaryTreeNode
{
    int value;
    BinaryTreeNode* left;
    BinaryTreeNode* right;
    BinaryTreeNode(int data=int()):value(data),left(NULL),right(NULL)
    {}
}
</code></pre>

<hr />

<h3>分析</h3>

<p>对二叉树而言，第n层最少有1个节点，最多有2<sup>n-1</sup>个节点。很明显，要以层序打印二叉树，就要在遍历时将当前层的节点保存起来，目的有两个，一是为了遍历以当前层节点为跟的子树，二是为了打印这些节点。</p>

<p>二叉树的层序遍历在广义上可看成是一种“广度优先搜索”策略，由此我们联想的图算法中的广度优先搜索算法，采用“队列”这个数据结构。思想如下：</p>

<p>先将根节点放入队列，而后在循环中将队列的队首的左右子树放进队列。要注意的是，题目要求按从左到右的顺序打印，所以需要先push右子树，再push左子树。如此循环直到队列为空即可。</p>

<p>代码如下：</p>

<pre><code>void PrintFromTopToBottom(BinaryTreeNode* root)
{
    if(root==NULL)
        return;
    queue&lt;binarytreenode&gt; q;
    q.push(root);
    while(!q.empty())
    {
        if(q.front()-&gt;left!=NULL)
            q.push(q.front()-&gt;left);
        if(q.front()-&gt;right!=NULL)
            q.push(q.front()-&gt;right);
        cout&lt;&lt;q.front-&gt;value&lt;&lt;&quot; &quot;;
        q.pop();
    }
    cout&lt;&lt;endl;
}
&lt;/q.front-&gt;&lt;/binarytreenode&gt;```

**以上**

如果你有任何想法或是可以改进的地方，欢迎和我交流！

完整代码及测试用例在github上：[点我前往](https://github.com/SmartBrave/Sword-to-Offer/blob/master/23_PrintBinaryTree/main.cpp)

&lt;div&gt;[来自为知笔记(Wiz)](http://www.wiz.cn/i/96171253 &quot;来自为知笔记(Wiz)&quot;)&lt;/div&gt;

??自为知笔记(Wiz)&quot;)&lt;/div&gt;

</code></pre>

    </div>
</body>

<footer>
    <div class="footer">
        Copyright © sbrave 2021
        <br>
        陕ICP备16005721号-1
    </div>
</footer>

</html>

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/haoel/anti-baidu@0.6.2/js/anti-baidu-latest.min.js" charset="UTF-8"></script>
