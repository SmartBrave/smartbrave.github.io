<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=0.5">

    <link href="/css/main.css" rel="stylesheet" type="text/css">
    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">
    <link rel="shortcut icon" href="/image/Yc.jpg">
    <link href="/css/prism.css" rel="stylesheet" />
    <title>选择排序</title>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-78070816-3"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }
        gtag('js', new Date());

        gtag('config', 'UA-78070816-3');
    </script>
</head>

<body>
    <!-- suppport block of mathjax -->
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
    <!-- support mathjax inline -->
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
                tex2jax: {inlineMath: [['$','$']]},
                messageStyle: "none"
            });
        </script>
    <script>
        if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent)) {
            document.body.classList.add('mobile');
        }
    </script>
    <script src="/js/prism.js"></script>
    <div class="inner">
        <h2>选择排序</h2>

<p>我个人认为冒泡排序和选择排序真是一对孪生兄弟，因为我总感觉这两个算法的思想很像，时间复杂度也相同。但其实他们的算法思想是不同的。</p>

<p>冒泡排序是从前往后逐个比较相邻的元素，从而使得最大的元素”冒”到数组的最右边。</p>

<p>而选择排序则是将某一个元素与其余所有元素相比较，选出一个最小/最大的元素放在当前位置。</p>

<p>代码如下：</p>

<p>```template<typename T>
void SelectSort(vector<T>&amp; v)
{
    if(v.size()&lt;=1)
        return;
    int length=v.size();
    int i,j;
    for(i=0;i&lt;length;++i)
    {
        for(j=i+1;j&lt;length;++j)
        {
            if(-1==compair(v[j],v[i]))
            {
                swap(v[j],v[i]);
            }
        }
    }
}</p>

<pre><code>

在[这里](/post/cf4cc8e2/14e6f1eb)说过，”所有基于位置的比较排序的时间复杂度都逃不了O(n&lt;sup&gt;2&lt;/sup&gt;)的厄运”，所以选择排序的时间复杂度同样也是O(n&lt;sup&gt;2&lt;/sup&gt;)。

同样来看看可以改进的地方： 

**改进一：如果一趟排序中没有进行交换，则表明排序完成。**具体算法再冒泡排序中说过，再次不在表述。

**改进二：在每一趟排序中进行双向选择。** 

代码如下：

```template&lt;typename T&gt;
void SelectSort(vector&lt;T&gt;&amp;amp; v)
{
    if(v.size()&lt;=1)
        return;
    int length=v.size();
    int i,j;
    for(i=0;i&lt;length;++i)
    {
        for(j=i+1;j&lt;length-i;++j)
        {
            int ma=max(v,i,j,length-i-1);
            int mi=min(v,i,j,length-i-1);
            swap(v[i],v[mi]);
            if(1==compair(v[ma],v[length-i-1]))
                swap(v[length-i-1],v[ma]);
        }
    }
}
</code></pre>

<p><strong>以上</strong></p>

<p>如果你有任何想法或是可以改进的地方，欢迎和我交流！</p>

<p>完整代码及测试用例在github上：<a href="https://github.com/SmartBrave/DataStruct/blob/master/Sort/SelectSort/main.cpp">点我前往</a></p>

    </div>
</body>

<footer>
    <div class="footer">
        Copyright © sbrave 2021
        <br>
        陕ICP备16005721号-1
    </div>
</footer>

</html>

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/haoel/anti-baidu@0.6.2/js/anti-baidu-latest.min.js" charset="UTF-8"></script>
